"""
CadQuery Geodesic Dome Generator with Wedged Struts.

This module generates geodesic dome structures with wedged struts - trapezoidal 
prisms whose side faces are radial planes passing through the dome center.
"""

import cadquery as cq
from typing import List, Tuple, Dict, Optional

from .geometry import (
    Point3D,
    generate_geodesic_dome,
    generate_honeycomb_dome,
    build_vertex_to_edges_map,
    normalize, sub, add, scale, dot, compute_tangent_basis
)

from .wedged_struts import (
    create_strut_from_edge
)

from .cuboid_struts import (
    create_cuboid_strut_from_edge,
    create_shortened_cuboid_strut
)

from .hubs import (
    compute_hub_geometry,
    create_hub_solid,
    create_hub_by_style,
    calculate_hub_corner
)

from .miter_struts import (
    create_miter_cut_strut,
    analyze_miter_cuts_for_dome
)


# =============================================================================
# DOME GENERATION
# =============================================================================

def generate_window_plates(
    vertices: List[Point3D],
    faces: List[List[int]],
    strut_depth: float,
    strut_width: float,
    plate_depth: float = 2.54,
    dome_center: Point3D = (0, 0, 0),
    margin: float = 0.2,
    hub_inset: float = 0.0
) -> cq.Compound:
    """
    Generate window plates that fit just inside the window openings.
    
    The plates are prisms generated by calculating the exact hub corners that frame
    the window, projecting them onto a best-fit window plane, and offsetting inward.
    
    Args:
        vertices: All vertices
        faces: List of faces (lists of vertex indices)
        strut_depth: Depth of struts
        strut_width: Width of struts (used for fallback or margin)
        plate_depth: Thickness of the plate
        dome_center: Center of the dome
        margin: Extra gap between plate and hubs
        hub_inset: Distance struts are shortened (required for corner calculation)
        
    Returns:
        Compound containing all window plates
    """
    plates = []
    
    for face in faces:
        if len(face) < 3:
            continue
            
        # Calculate centroid and direction
        face_verts_coords = [vertices[i] for i in face]
        cx = sum(v[0] for v in face_verts_coords) / len(face_verts_coords)
        cy = sum(v[1] for v in face_verts_coords) / len(face_verts_coords)
        cz = sum(v[2] for v in face_verts_coords) / len(face_verts_coords)
        centroid = (cx, cy, cz)
        
        # Window direction (from origin to centroid)
        window_dir = normalize(sub(centroid, dome_center))
        
        # Calculate the actual hub corners for this window
        hub_corners = []
        n = len(face)
        
        for i in range(n):
            # Current vertex and neighbors in the loop
            curr_idx = face[i]
            prev_idx = face[(i - 1 + n) % n]
            next_idx = face[(i + 1) % n]
            
            vertex = vertices[curr_idx]
            
            # Directions to neighbors
            # The window loop is typically ordered, so we can find the two struts
            # that define this window angle at the current vertex
            d_prev = normalize(sub(vertices[prev_idx], vertex))
            d_next = normalize(sub(vertices[next_idx], vertex))
            
            radial = normalize(sub(vertex, dome_center))
            
            # Calculate the corner of the hub between these two struts
            corner = calculate_hub_corner(
                vertex, radial, d_prev, d_next, hub_inset, strut_depth
            )
            hub_corners.append(corner)
            
        # Determine window plane distance from origin
        # We want the plate to be just inside the hubs.
        # Find the corner closest to the dome center (projected onto window_dir)
        u_values = [dot(sub(p, dome_center), window_dir) for p in hub_corners]
        u_min = min(u_values)
        
        # Plane center at u_min along window_dir
        plane_center = add(dome_center, scale(window_dir, u_min))
        
        # Tangent basis for the window plane
        u_vec, v_vec = compute_tangent_basis(window_dir)
        
        # Project corners to 2D on this plane
        points_2d = []
        for p in hub_corners:
            # We project along the window normal (orthographic projection onto plane)
            # Relative vector from plane center
            rel = sub(p, plane_center)
            x2d = dot(rel, u_vec)
            y2d = dot(rel, v_vec)
            points_2d.append((x2d, y2d))
            
        # Create plate
        try:
            # Create Workplane with origin at plane_center and normal=window_dir
            wp = cq.Workplane(cq.Plane(origin=plane_center, xDir=u_vec, normal=window_dir))
            
            # Draw initial polygon from hub corners
            poly = wp.polyline(points_2d).close()
            
            # Offset inward by margin only
            # Since the polygon is already at the hub corners (the frame),
            # we just need to shrink it by the margin to "hover".
            # Strut width is already accounted for in calculate_hub_corner implicitly
            # because hub corners are where struts meet.
            # Actually, calculate_hub_corner gives the point where the cut planes intersect.
            # Those cut planes are defined by strut width. So the corner IS the inner boundary.
            offset_val = -margin
            
            # Extrude
            plate = poly.offset2D(offset_val).extrude(plate_depth)
            
            plates.append(plate.val())
        except Exception:
            pass
            
    return cq.Compound.makeCompound(plates) if plates else cq.Compound.makeCompound([])


def generate_dome_with_hubs(
    radius_cm: float,
    frequency: int,
    portion: float = 0.5,
    strut_width: float = 5.08,
    strut_depth: float = 5.08,
    dome_style: str = "honeycomb",
    hub_inset: Optional[float] = None,
    hub_style: str = "convex_hull",
    strut_style: str = "cuboid",
    max_struts: int = -1,
    generate_windows: bool = False,
    window_plate_depth: float = 2.54,
    window_margin: float = 0.2
) -> Tuple[cq.Compound, cq.Compound, cq.Compound, Dict]:
    """
    Generate a geodesic dome with hub joints (non-overlapping struts).
    
    Struts are shortened to leave room for hub connectors at each vertex.
    
    Args:
        radius_cm: Dome radius in centimeters
        frequency: Geodesic frequency (1-6, higher = more subdivisions)
        portion: Sphere portion (0.5 = hemisphere)
        strut_width: Width of strut cross-section in cm
        strut_depth: Depth of strut (radial thickness) in cm
        dome_style: "honeycomb" (hex/pent) or "triangular"
        hub_inset: How far struts are shortened from vertices (default: 0.35x strut_width)
        hub_style: "convex_hull", "tapered_prism", or "cylindrical_core"
        strut_style: "cuboid" (standard) or "miter_cut" (for cylindrical_core hubs)
        max_struts: Maximum struts to generate (-1 = all)
        generate_windows: Whether to generate window plates
        window_plate_depth: Depth/thickness of window plates
        window_margin: Extra gap between window plate and struts/hubs
    
    Returns:
        Tuple of (struts_compound, hubs_compound, windows_compound, info dict)
    """
    dome_center = (0.0, 0.0, 0.0)
    
    # Default hub inset based on strut width
    if hub_inset is None:
        # Hub inset = how much struts are shortened
        # Should match the hub face distance so struts meet the hub faces
        hub_inset = strut_width * 0.35
    
    # STRATEGY: Generate extended geometry to ensure boundary hubs have full context
    # We generate a slightly larger portion to include "ghost" neighbors for the bottom ring.
    # This allows boundary hubs to be generated as if they were interior hubs (3+ struts),
    # preventing misshapen 2-strut "bar" hubs.
    extended_portion = min(1.0, portion + 0.15)
    
    # Generate dome geometry based on style (using extended portion)
    if dome_style == "honeycomb":
        vertices, faces, edges = generate_honeycomb_dome(radius_cm, frequency, extended_portion, strut_width)
    else:
        vertices, faces, edges = generate_geodesic_dome(radius_cm, frequency, extended_portion)
    
    # Build vertex to edges map (includes ghost connections from extended geometry)
    vertex_to_edges = build_vertex_to_edges_map(edges)
    
    # Calculate cutoff height for the requested portion to filter active struts
    # Note: geometry uses Y-up, and center is at (0,0,0)
    cutoff_y = -radius_cm * (2 * portion - 1)
    
    # Cut plane for struts: slightly below the official cutoff to prevent longitudinal cuts
    # for struts lying on the boundary.
    cut_plane_y = cutoff_y - (strut_width / 2.0)
    
    tolerance = 0.1  # cm tolerance for floating point comparisons
    
    # Identify "active" edges for STRUTS - those that are above the cut plane
    # We include edges that cross the boundary so we can cut them later
    active_edges = []
    
    for v1_idx, v2_idx in edges:
        v1 = vertices[v1_idx]
        v2 = vertices[v2_idx]
        
        # An edge is active if AT LEAST ONE vertex is effectively above the cut plane
        # (or if the edge crosses it, which implies at least one is above)
        if v1[1] >= cut_plane_y - tolerance or v2[1] >= cut_plane_y - tolerance:
            active_edges.append((v1_idx, v2_idx))
    
    # Limit struts if requested
    edges_to_use = active_edges[:max_struts] if max_struts > 0 else active_edges
    
    # Create struts (potentially including "ghost" parts)
    strut_shapes = []
    
    # Prepare cutter object: A huge box that removes everything below cut_plane_y
    # Box needs to be big enough to cover the whole dome area below the cut.
    # We create a box that extends from very low up to cut_plane_y.
    huge_dim = radius_cm * 10
    
    # Calculate box dimensions
    lx = 2 * huge_dim
    ly = cut_plane_y - (-huge_dim)
    lz = 2 * huge_dim
    
    # Create box and move it to position
    cutter_solid = cq.Solid.makeBox(lx, ly, lz).translate(cq.Vector(-huge_dim, -huge_dim, -huge_dim))

    for v1_idx, v2_idx in edges_to_use:
        start = vertices[v1_idx]
        end = vertices[v2_idx]
        
        if strut_style == "miter_cut":
            strut = create_miter_cut_strut(
                start, end, strut_width, strut_depth,
                hub_inset, hub_inset, dome_center
            )
        else:
            strut = create_shortened_cuboid_strut(
                start, end, strut_width, strut_depth,
                hub_inset, hub_inset, dome_center
            )
        
        # Cut the strut at the plane
        try:
            cut_strut = strut.cut(cutter_solid)
            if cut_strut.isValid() and not cut_strut.Volume() < 1e-6:
                strut_shapes.append(cut_strut)
        except Exception:
            # If cut fails (e.g. strut is fully outside?), skip
            pass
    
    # Create hubs at each active vertex
    hub_shapes = []
    hub_infos = []
    
    # Find which vertices are involved in the active structure
    used_vertices_from_edges = set()
    for v1_idx, v2_idx in edges_to_use:
        used_vertices_from_edges.add(v1_idx)
        used_vertices_from_edges.add(v2_idx)
    
    # Only generate hubs for vertices that are strictly within the dome portion
    # (i.e. we don't want hubs for the "ghost" ends of cut struts)
    valid_hub_vertices = []
    for v_idx in used_vertices_from_edges:
        if vertices[v_idx][1] >= cutoff_y - tolerance:
            valid_hub_vertices.append(v_idx)

    for v_idx in valid_hub_vertices:
        vertex = vertices[v_idx]
        
        # Compute hub geometry using the FULL set of edges/vertices (including extended geometry)
        # This allows the hub generator to see "ghost" struts and create the correct 
        # tapered prism shape even for boundary vertices that only have 2 active struts.
        hub_info = compute_hub_geometry(
            vertex, v_idx, vertices, edges, vertex_to_edges,
            strut_width, strut_depth, hub_inset, dome_center
        )
        hub_infos.append(hub_info)
        
        # Create hub solid using specified style
        hub = create_hub_by_style(hub_info, strut_width, strut_depth, dome_center, hub_style)
        if hub is not None:
            hub_shapes.append(hub)
    
    # Combine into compounds
    struts_compound = cq.Compound.makeCompound(strut_shapes) if strut_shapes else cq.Compound.makeCompound([])
    hubs_compound = cq.Compound.makeCompound(hub_shapes) if hub_shapes else cq.Compound.makeCompound([])
    
    # Generate windows if requested
    windows_compound = cq.Compound.makeCompound([])
    if generate_windows and hub_inset is not None:
        windows_compound = generate_window_plates(
            vertices, faces, strut_depth, strut_width, window_plate_depth, dome_center, window_margin, hub_inset
        )
        
        # Cut window plates if they extend below the cut plane
        try:
            cut_windows = windows_compound.cut(cutter_solid)
            if cut_windows.isValid() and cut_windows.Volume() > 1e-6:
                windows_compound = cut_windows
        except Exception:
            pass
    
    info = {
        'num_vertices': len(valid_hub_vertices),
        'num_edges': len(active_edges),
        'num_faces': len(faces),
        'num_struts_generated': len(strut_shapes),
        'num_hubs_generated': len(hub_shapes),
        'num_windows_generated': len(windows_compound.Solids()) if generate_windows else 0,
        'vertices': vertices, # Must return extended vertices as indices refer to them
        'edges': active_edges, # Return only the active edges
        'faces': faces,
        'hub_infos': hub_infos,
        'radius_cm': radius_cm,
        'frequency': frequency,
        'portion': portion,
        'strut_width': strut_width,
        'strut_depth': strut_depth,
        'hub_inset': hub_inset,
        'strut_style': strut_style,
        'hub_style': hub_style,
        'joint_style': 'hub',
    }
    
    return struts_compound, hubs_compound, windows_compound, info


def generate_dome(
    radius_cm: float,
    frequency: int,
    portion: float = 0.5,
    strut_width: float = 5.08,
    strut_depth: float = 5.08,
    dome_style: str = "honeycomb",
    strut_style: str = "wedged",
    joint_style: str = "overlap",
    hub_inset: Optional[float] = None,
    max_struts: int = -1,
    generate_windows: bool = False,
    window_plate_depth: float = 2.54,
    window_margin: float = 0.2
) -> Tuple[cq.Compound, Dict]:
    """
    Generate a complete geodesic dome with struts.
    
    Args:
        radius_cm: Dome radius in centimeters
        frequency: Geodesic frequency (1-6, higher = more subdivisions)
        portion: Sphere portion (0.5 = hemisphere)
        strut_width: Width of strut cross-section in cm
        strut_depth: Depth of strut (radial thickness) in cm
        dome_style: "honeycomb" (hex/pent) or "triangular"
        strut_style: "wedged" (trapezoidal, radial faces) or "cuboid" (rectangular box)
        joint_style: "overlap" (struts meet at vertices) or "hub" (struts shortened for hub joints)
        hub_inset: How far struts are shortened for hub joints (default: 1.5x strut_width)
        max_struts: Maximum struts to generate (-1 = all)
        generate_windows: Whether to generate window plates
        window_plate_depth: Depth/thickness of window plates
        window_margin: Extra gap between window plate and struts/hubs
    
    Returns:
        Tuple of (compound solid, info dict with vertices/edges/faces)
        For joint_style="hub", the compound contains struts, hubs, and windows (if enabled)
    """
    # If hub joint style, use the dedicated function
    if joint_style == "hub":
        struts, hubs, windows, info = generate_dome_with_hubs(
            radius_cm=radius_cm,
            frequency=frequency,
            portion=portion,
            strut_width=strut_width,
            strut_depth=strut_depth,
            dome_style=dome_style,
            hub_inset=hub_inset,
            max_struts=max_struts,
            generate_windows=generate_windows,
            window_plate_depth=window_plate_depth,
            window_margin=window_margin
        )
        # Combine struts and hubs into one compound
        all_shapes = []
        for solid in struts.Solids():
            all_shapes.append(solid)
        for solid in hubs.Solids():
            all_shapes.append(solid)
        if generate_windows:
            for solid in windows.Solids():
                all_shapes.append(solid)
        result = cq.Compound.makeCompound(all_shapes) if all_shapes else cq.Compound.makeCompound([])
        return result, info
    
    # Standard overlap mode
    dome_center = (0.0, 0.0, 0.0)
    
    # Generate dome geometry based on style
    if dome_style == "honeycomb":
        vertices, faces, edges = generate_honeycomb_dome(radius_cm, frequency, portion, strut_width)
    else:
        vertices, faces, edges = generate_geodesic_dome(radius_cm, frequency, portion)
    
    # Limit struts if requested
    if max_struts > 0:
        edges = edges[:max_struts]
    
    # Select strut creation function based on style
    if strut_style == "cuboid":
        strut_func = create_cuboid_strut_from_edge
    else:
        strut_func = create_strut_from_edge
    
    # Create all struts
    strut_shapes = []
    
    for v1_idx, v2_idx in edges:
        start = vertices[v1_idx]
        end = vertices[v2_idx]
        
        strut = strut_func(start, end, strut_width, strut_depth, dome_center)
        strut_shapes.append(strut)
    
    # Combine all struts into one compound
    if strut_shapes:
        result = cq.Compound.makeCompound(strut_shapes)
    else:
        result = cq.Compound.makeCompound([])
    
    info = {
        'num_vertices': len(vertices),
        'num_edges': len(edges),
        'num_faces': len(faces),
        'vertices': vertices,
        'edges': edges,
        'faces': faces,
        'radius_cm': radius_cm,
        'frequency': frequency,
        'portion': portion,
        'strut_width': strut_width,
        'strut_depth': strut_depth,
        'strut_style': strut_style,
        'joint_style': joint_style,
    }
    
    return result, info


def generate_dome_struts_individually(
    radius_cm: float,
    frequency: int,
    portion: float = 0.5,
    strut_width: float = 5.08,
    strut_depth: float = 5.08,
    dome_style: str = "honeycomb",
    strut_style: str = "wedged",
    max_struts: int = -1
) -> Tuple[List[cq.Shape], Dict]:
    """
    Generate dome struts as individual shapes (useful for debugging/visualization).
    
    Same parameters as generate_dome, but returns a list of individual strut shapes
    instead of a compound.
    """
    dome_center = (0.0, 0.0, 0.0)
    
    # Generate dome geometry based on style
    if dome_style == "honeycomb":
        vertices, faces, edges = generate_honeycomb_dome(radius_cm, frequency, portion, strut_width)
    else:
        vertices, faces, edges = generate_geodesic_dome(radius_cm, frequency, portion)
    
    # Limit struts if requested
    if max_struts > 0:
        edges = edges[:max_struts]
    
    # Select strut creation function based on style
    if strut_style == "cuboid":
        strut_func = create_cuboid_strut_from_edge
    else:
        strut_func = create_strut_from_edge
    
    # Create all struts
    strut_shapes = []
    
    for v1_idx, v2_idx in edges:
        start = vertices[v1_idx]
        end = vertices[v2_idx]
        
        strut = strut_func(start, end, strut_width, strut_depth, dome_center)
        strut_shapes.append(strut)
    
    info = {
        'num_vertices': len(vertices),
        'num_edges': len(edges),
        'num_faces': len(faces),
        'vertices': vertices,
        'edges': edges,
        'faces': faces,
        'radius_cm': radius_cm,
        'frequency': frequency,
        'portion': portion,
        'strut_width': strut_width,
        'strut_depth': strut_depth,
        'strut_style': strut_style,
    }
    
    return strut_shapes, info


# =============================================================================
# EXPORT FUNCTIONS
# =============================================================================

def export_dome(
    dome: cq.Compound,
    step_path: Optional[str] = None,
    stl_path: Optional[str] = None
) -> None:
    """
    Export the dome to STEP and/or STL files.
    
    Args:
        dome: The dome compound to export
        step_path: Path for STEP file (None to skip)
        stl_path: Path for STL file (None to skip)
    """
    # Wrap the compound in a Workplane for export
    wp = cq.Workplane("XY").newObject([dome])
    
    if step_path:
        cq.exporters.export(wp, step_path)
        print(f"Exported STEP to: {step_path}")
    
    if stl_path:
        cq.exporters.export(wp, stl_path)
        print(f"Exported STL to: {stl_path}")


# =============================================================================
# CONVENIENCE / PRESET FUNCTIONS
# =============================================================================

def generate_2v_test_dome(
    radius_cm: float = 100.0,
    strut_width: float = 5.0,
    strut_depth: float = 5.0,
    strut_style: str = "wedged",
    max_struts: int = 10
) -> Tuple[cq.Compound, Dict]:
    """
    Generate a simple 2V dome for testing.
    
    This is useful for verifying the geometry before generating a full dome.
    """
    return generate_dome(
        radius_cm=radius_cm,
        frequency=2,
        portion=0.5,
        strut_width=strut_width,
        strut_depth=strut_depth,
        dome_style="honeycomb",
        strut_style=strut_style,
        max_struts=max_struts
    )


def generate_chapel_dome(
    radius_ft: float = 8.0,
    frequency: int = 3,
    strut_width_in: float = 2.0,
    strut_depth_in: float = 2.0,
    strut_style: str = "wedged",
    joint_style: str = "overlap",
    hub_style: str = "convex_hull",
    hub_inset_in: Optional[float] = None,
    generate_windows: bool = False,
    window_plate_depth_in: float = 1.0,
    window_margin_in: float = 0.1
) -> Tuple[cq.Compound, Dict]:
    """
    Generate the Chapel of MOOP dome with standard parameters.
    
    Args:
        radius_ft: Dome radius in feet
        frequency: Geodesic frequency (3 recommended)
        strut_width_in: Strut width in inches
        strut_depth_in: Strut depth in inches
        strut_style: "wedged", "cuboid", or "miter_cut"
        joint_style: "overlap" (struts meet at vertices) or "hub" (struts shortened for hub joints)
        hub_style: "convex_hull", "tapered_prism", or "cylindrical_core"
        hub_inset_in: How far struts are shortened for hubs, in inches (default auto-calculated)
        generate_windows: Whether to generate window plates
        window_plate_depth_in: Depth/thickness of window plates in inches
        window_margin_in: Extra gap between window plate and struts/hubs in inches
    
    Returns:
        Tuple of (compound, info dict)
    """
    # Convert to centimeters
    radius_cm = radius_ft * 30.48
    strut_width = strut_width_in * 2.54
    strut_depth = strut_depth_in * 2.54
    hub_inset = hub_inset_in * 2.54 if hub_inset_in is not None else None
    window_plate_depth = window_plate_depth_in * 2.54
    window_margin = window_margin_in * 2.54
    
    if joint_style == "hub":
        struts, hubs, windows, info = generate_dome_with_hubs(
            radius_cm=radius_cm,
            frequency=frequency,
            portion=0.5,
            strut_width=strut_width,
            strut_depth=strut_depth,
            dome_style="honeycomb",
            hub_inset=hub_inset,
            hub_style=hub_style,
            strut_style=strut_style if strut_style in ["cuboid", "miter_cut"] else "cuboid",
            generate_windows=generate_windows,
            window_plate_depth=window_plate_depth,
            window_margin=window_margin
        )
        # Combine struts and hubs into one compound
        all_shapes = []
        for solid in struts.Solids():
            all_shapes.append(solid)
        for solid in hubs.Solids():
            all_shapes.append(solid)
        if generate_windows:
            for solid in windows.Solids():
                all_shapes.append(solid)
        result = cq.Compound.makeCompound(all_shapes) if all_shapes else cq.Compound.makeCompound([])
        return result, info
    
    return generate_dome(
        radius_cm=radius_cm,
        frequency=frequency,
        portion=0.5,
        strut_width=strut_width,
        strut_depth=strut_depth,
        dome_style="honeycomb",
        strut_style=strut_style,
        joint_style=joint_style,
        hub_inset=hub_inset,
        generate_windows=generate_windows,
        window_plate_depth=window_plate_depth,
        window_margin=window_margin
    )


# =============================================================================
# MAIN (for standalone testing)
# =============================================================================

if __name__ == "__main__":
    print("Generating test dome...")
    
    # Generate a simple 2V test dome
    dome, info = generate_2v_test_dome(radius_cm=100, max_struts=10)
    
    print(f"Generated dome with:")
    print(f"  Vertices: {info['num_vertices']}")
    print(f"  Edges: {info['num_edges']}")
    print(f"  Faces: {info['num_faces']}")
    
    # Export to files
    export_dome(dome, step_path="output/test_dome.step", stl_path="output/test_dome.stl")
    
    print("Done!")
